#include <SPI.h>
#include <LovyanGFX.hpp> // Instalar via Library Manager
#include <ESP32Servo.h>

// --- CONFIGURAÇÃO DO ECRÃ (LOVYANGFX) ---
class LGFX : public lgfx::LGFX_Device {
  lgfx::Panel_ILI9488 _panel_instance; // Driver ILI9488 (comum em 3.5")
  lgfx::Bus_SPI       _bus_instance;   // Barramento SPI

public:
  LGFX(void) {
    {
      auto cfg = _bus_instance.config();
      
      // CONFIGURAÇÃO DOS PINOS SPI (ESP32-C6)
      // Ajusta se tiveres ligado noutros pinos, mas estes são padrão para SPI
      cfg.spi_host = SPI2_HOST; // Usar SPI2 no C6
      cfg.spi_mode = 0;
      cfg.freq_write = 40000000; // 40MHz
      cfg.freq_read  = 16000000;
      cfg.spi_3wire  = false; // SPI normal (4 fios)
      cfg.use_lock   = true;
      cfg.dma_channel = SPI_DMA_CH_AUTO;

      // Pinos definidos pelo utilizador
      cfg.pin_sclk = 21;  // SCK (Confirma na tua placa, C6 costuma ser 21 ou 20)
      cfg.pin_mosi = 19;  // MOSI (Confirma na tua placa, C6 costuma ser 19 ou 21)
      cfg.pin_miso = -1;  // MISO (Não precisamos de ler do ecrã)
      cfg.pin_dc   = 22;  // Data/Command
      
      _bus_instance.config(cfg);
      _panel_instance.setBus(&_bus_instance);
    }

    {
      auto cfg = _panel_instance.config();

      cfg.pin_cs           = 15;  // Chip Select
      cfg.pin_rst          = 23;  // Reset
      cfg.pin_busy         = -1; 

      cfg.panel_width      = 320;
      cfg.panel_height     = 480;
      cfg.offset_x         = 0;
      cfg.offset_y         = 0;
      cfg.offset_rotation  = 0;
      cfg.dummy_read_pixel = 8;
      cfg.dummy_read_bits  = 1;
      cfg.readable         = false; // ILI9488 SPI muitas vezes não permite leitura
      cfg.invert           = false;
      cfg.rgb_order        = false;
      cfg.dlen_16bit       = false;
      cfg.bus_shared       = false; 

      _panel_instance.config(cfg);
    }
    
    setPanel(&_panel_instance);
  }
};

LGFX tft;                 // Instância do ecrã
Servo myServo; 

// --- PINOS DO RADAR ---
#define trigPin   4   
#define echoPin   5   
#define ServoPin  14 
#define ButtonPin 2 

// --- DEFINIÇÕES ---
#define MAX_DISTANCE_CM 150 
#define SCAN_RADIUS 280     
#define CENTER_X 240        
#define CENTER_Y 320     

int radarSpeed =200;

// --- MEMÓRIA (91 POSIÇÕES) ---
int background0to180[91];   
int background180to0[91];   

bool calibrated = false;    
bool systemActive = false;  

void setup() {
  // 1. Hardware
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  pinMode(ButtonPin, INPUT_PULLUP);
  
  for(int i=0; i<91; i++) {
    background0to180[i] = 0;
    background180to0[i] = 0;
  }

  myServo.setPeriodHertz(50);
  myServo.attach(ServoPin, 500, 2400);
  myServo.write(90);

  Serial.begin(115200);

  // 2. TFT Init
  tft.init();
  tft.setRotation(1); // Paisagem
  tft.fillScreen(TFT_BLACK);

  // 3. Ecrã Inicial
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.drawCenterString("RADAR C6 LOVYAN", CENTER_X, 100);
  tft.setTextColor(TFT_YELLOW, TFT_BLACK);
  tft.drawCenterString("PRESSIONE BOTAO", CENTER_X, 140);
  tft.drawCenterString("PARA CALIBRAR", CENTER_X, 170);
}

// --- MEDIÇÃO ---
int calculateDistance() { 
  digitalWrite(trigPin, LOW); 
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH); 
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH, 25000); 
  if(duration == 0) return MAX_DISTANCE_CM + 10; 
  return duration * 0.034 / 2;
}

// --- DESENHO GRELHA ---
void drawGrid() {
  tft.drawCircle(CENTER_X, CENTER_Y, SCAN_RADIUS, TFT_DARKGREEN);       
  tft.drawCircle(CENTER_X, CENTER_Y, SCAN_RADIUS*0.66, TFT_DARKGREEN);  
  tft.drawCircle(CENTER_X, CENTER_Y, SCAN_RADIUS*0.33, TFT_DARKGREEN);  

  for (int i=30; i<=150; i+=30) {
    float rad = radians(i);
    int x = CENTER_X + SCAN_RADIUS * cos(rad);
    int y = CENTER_Y - SCAN_RADIUS * sin(rad);
    tft.drawLine(CENTER_X, CENTER_Y, x, y, TFT_DARKGREEN);
  }
}

// --- VISUALIZAÇÃO ---
void renderRadarLine(int angle, int distance, bool isIntruder) {
  float rad = radians(angle);
  float cosA = cos(rad);
  float sinA = sin(rad);

  int lineX = CENTER_X + SCAN_RADIUS * cosA;
  int lineY = CENTER_Y - SCAN_RADIUS * sinA;
  tft.drawLine(CENTER_X, CENTER_Y, lineX, lineY, TFT_GREEN);

  if (isIntruder && distance < MAX_DISTANCE_CM) {
    // Mapeamento de distância
    int pixelDist = map(distance, 0, MAX_DISTANCE_CM, 0, SCAN_RADIUS);
    int objX = CENTER_X + pixelDist * cosA;
    int objY = CENTER_Y - pixelDist * sinA;
    
    tft.fillCircle(objX, objY, 5, TFT_RED);
    
    // Alerta
    tft.fillRect(0, 0, 100, 30, TFT_BLACK);
    tft.setTextColor(TFT_RED, TFT_BLACK); 
    tft.setTextSize(2);
    tft.setCursor(5, 5);
    tft.print("ALERTA!");
  } else {
    // Info Normal
    tft.fillRect(0, 0, 100, 30, TFT_BLACK);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setTextSize(1);
    tft.setCursor(5, 5);
    tft.print("Scan...");
  }

  // Debug Canto
  tft.fillRect(380, 0, 100, 40, TFT_BLACK);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.setCursor(390, 5); tft.print("Ang: "); tft.print(angle);
  tft.setCursor(390, 20); tft.print("Dst: "); tft.print(distance);
}

void clearRadarLine(int angle) {
  float rad = radians(angle);
  int x = CENTER_X + SCAN_RADIUS * cos(rad);
  int y = CENTER_Y - SCAN_RADIUS * sin(rad);
  tft.drawLine(CENTER_X, CENTER_Y, x, y, TFT_BLACK);
  
  if (angle % 30 == 0) tft.drawLine(CENTER_X, CENTER_Y, x, y, TFT_DARKGREEN);
}

void loop() {
  // MODO CALIBRAÇÃO
  if (!systemActive) {
    if (digitalRead(ButtonPin) == LOW) {
      tft.fillScreen(TFT_BLACK);
      
      tft.setTextColor(TFT_CYAN, TFT_BLACK);
      tft.drawCenterString("CALIBRAR IDA...", CENTER_X, 140);
      
      // Calibração Ida
      for(int i=0; i<=180; i+=2) {
        myServo.write(i);
        delay(radarSpeed); // <--- AQUI (Velocidade controlada)
        background0to180[i/2] = calculateDistance();
      }

      tft.fillScreen(TFT_BLACK);
      
      // Calibração Volta
      tft.drawCenterString("CALIBRAR VOLTA...", CENTER_X, 140);
      for(int i=180; i>=0; i-=2) {
        myServo.write(i);
        delay(radarSpeed); // <--- AQUI
        background180to0[i/2] = calculateDistance();
      }
      
      calibrated = true;
      systemActive = true;
      tft.fillScreen(TFT_BLACK);
      drawGrid();
    } else {
      return;
    }
  }

  // MODO ATIVO (IDA)
  for (int i=0; i<=180; i+=2) {
    myServo.write(i);
    delay(radarSpeed); // <--- AQUI
    if(i > 0) clearRadarLine(i-2);

    int distAtual = calculateDistance();
    bool intruso = false;
    
    int index = i / 2;
    int distFundo = background0to180[index]; 

    if (abs(distAtual - distFundo) > 10 && distAtual < MAX_DISTANCE_CM && distAtual > 0) {
      intruso = true;
    } else {
      if (abs(distAtual - distFundo) < 5) background0to180[index] = distAtual; 
    }

    renderRadarLine(i, distAtual, intruso);
  }
  clearRadarLine(180);

  // MODO ATIVO (VOLTA)
  for (int i=180; i>=0; i-=2) {
    myServo.write(i);
    delay(radarSpeed); // <--- AQUI
    if(i < 180) clearRadarLine(i+2);

    int distAtual = calculateDistance();
    bool intruso = false;

    int index = i / 2;
    int distFundo = background180to0[index];

    if (abs(distAtual - distFundo) > 10 && distAtual < MAX_DISTANCE_CM && distAtual > 0) {
      intruso = true;
    } else {
      if (abs(distAtual - distFundo) < 5) background180to0[index] = distAtual;
    }

    renderRadarLine(i, distAtual, intruso);
  }
  clearRadarLine(0);
}