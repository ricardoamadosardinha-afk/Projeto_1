// --- BIBLIOTECAS ---
#include <ESP32Servo.h> 
#include <SPI.h>
#include "Ucglib.h"            

// --- PINOS ESP32-C6 ---
#define  trigPin   4   
#define  echoPin   5   
#define  ServoPin  14 
#define  ButtonPin 2  // Botão entre Pino 2 e GND

// --- DEFINIÇÕES GERAIS ---
int Ymax = 240;              
int Xmax = 320;              
int Xcent = Xmax / 2;        
int base = 210;              
int scanline = 185;          
int stepDelay = 40; // Velocidade do varrimento

// --- MEMÓRIA DO RADAR (91 posições para ângulos 0 a 180, passo 2) ---
int history0to180[91]; 
int history180to0[91]; 

// --- VARIÁVEIS DE ESTADO ---
bool initialScanDone = false; 
bool systemActive = false; // Controla se o sistema já arrancou

Servo myServo; 

// CONFIGURAÇÃO DO DISPLAY (Pinos atualizados para evitar conflitos de Boot)
// CD (Data/Command) = 22
// CS (Chip Select)  = 15
// RESET             = 23
// NOTA: O MOSI (19) e SCK (21) são usados automaticamente pelo HWSPI
Ucglib_ILI9341_18x240x320_HWSPI ucg(/*cd=*/ 22, /*cs=*/ 15, /*reset=*/ 23);

void setup(void)
{
      // 1. Inicializar arrays a 0
      for(int i=0; i<91; i++) {
        history0to180[i] = 0;
        history180to0[i] = 0;
      }

      // 2. Configuração de Hardware
      myServo.setPeriodHertz(50); 
      pinMode(trigPin, OUTPUT);       
      pinMode(echoPin, INPUT);
      pinMode(ButtonPin, INPUT_PULLUP); // Botão com resistência interna
      
      Serial.begin(115200);
      Serial.println("--- RADAR A INICIALIZAR ---");

      myServo.attach(ServoPin, 500, 2400); 
      myServo.write(90); // Posição neutra ao ligar

      // 3. Inicializar TFT
      ucg.begin(UCG_FONT_MODE_SOLID); 
      ucg.setRotate90(); 
      
      // Ecrã de Boas Vindas / Standby
      ucg.setFontMode(UCG_FONT_MODE_TRANSPARENT);
      ucg.clearScreen();
      ucg.setColor(0, 0, 100, 0); // Fundo verde escuro
      ucg.drawGradientBox(0, 0, 320, 240);
      
      ucg.setColor(0, 255, 255, 255); // Branco
      ucg.setFont(ucg_font_logisoso32_tf);
      ucg.setPrintPos(40, 100);
      ucg.print("SISTEMA");
      ucg.setPrintPos(40, 140);
      ucg.print("PRONTO");
      
      ucg.setFont(ucg_font_courB14_tf);
      ucg.setColor(0, 255, 255, 0); // Amarelo
      ucg.setPrintPos(20, 200);
      ucg.print("PRESSIONE BOTAO...");
      
      Serial.println("AGUARDANDO BOTAO...");
}

// --- FUNÇÕES AUXILIARES DE DESENHO (ORIGINAIS) ---
void cls() {
  ucg.setColor(0, 0, 0, 0);
  for(int s=0;s<240;s++) {
    ucg.drawHLine(0,s,320);
  }
}

void fix_font() {
      ucg.setColor(0, 180, 0);
      ucg.setFont(ucg_font_helvR08_hr);
      ucg.setPrintPos(144,44);
      ucg.print("1.00");
      ucg.setPrintPos(144,100);
      ucg.print("0.60");
      ucg.setPrintPos(144,165);
      ucg.print("0.30");
}

void fix() {
      ucg.setColor(0, 180, 0);
      ucg.drawDisc(Xcent, base+1, 3, UCG_DRAW_ALL); 
      ucg.drawCircle(Xcent, base+1, 210, UCG_DRAW_UPPER_LEFT);
      ucg.drawCircle(Xcent, base+1, 210, UCG_DRAW_UPPER_RIGHT);
      ucg.drawCircle(Xcent, base+1, 135, UCG_DRAW_UPPER_LEFT);
      ucg.drawCircle(Xcent, base+1, 135, UCG_DRAW_UPPER_RIGHT);
      ucg.drawCircle(Xcent, base+1, 70, UCG_DRAW_UPPER_LEFT);
      ucg.drawCircle(Xcent, base+1, 70, UCG_DRAW_UPPER_RIGHT);
      ucg.drawLine(0, base+1, Xmax,base+1);
      
      ucg.setColor(0, 180, 0);
       for(int i= 40;i < 300; i+=2) {
        if (i % 10 == 0) 
          ucg.drawLine(185*cos(radians(i))+Xcent,base - 185*sin(radians(i)) , 205*cos(radians(i))+Xcent,base - 205*sin(radians(i)));
        else
          ucg.drawLine(195*cos(radians(i))+Xcent,base - 195*sin(radians(i)) , 205*cos(radians(i))+Xcent,base - 205*sin(radians(i)));
       }
}

// --- LÓGICA DO RADAR ---
int calculateDistance() { 
      long duration;
      digitalWrite(trigPin, LOW); 
      delayMicroseconds(2);
      digitalWrite(trigPin, HIGH); 
      delayMicroseconds(10);
      digitalWrite(trigPin, LOW);
      duration = pulseIn(echoPin, HIGH);
      return duration*0.034/2;
}

bool processarLogicaRadar(int angulo, int distanciaAtual, bool sentido0to180) {
    int* memoriaAtual = sentido0to180 ? history0to180 : history180to0;
    int index = angulo / 2;
    int distanciaAntiga = memoriaAtual[index];
    bool alerta = false;

    if (!initialScanDone) {
        memoriaAtual[index] = distanciaAtual;
        return false; 
    }

    if (abs(distanciaAtual - distanciaAntiga) > 20 && distanciaAntiga > 0) {
        alerta = true;
    }
    return alerta;
}

// --- DESENHO DINÂMICO ---
void desenharRadar(int x, int distance, bool alerta, bool sentidoInverso) {
      // 1. Linhas de Varrimento (Scanlines)
      int f = sentidoInverso ? (x - 4) : (x + 4); 
      
      ucg.setColor(0, 255, 0); 
      ucg.drawLine(Xcent, base, scanline*cos(radians(f))+Xcent,base - scanline*sin(radians(f)));
      
      f = sentidoInverso ? (f + 2) : (f - 2);
      ucg.setColor(0, 128, 0); 
      ucg.drawLine(Xcent, base, scanline*cos(radians(f))+Xcent,base - scanline*sin(radians(f)));
      
      f = sentidoInverso ? (f + 2) : (f - 2);
      ucg.setColor(0, 0, 0);   
      ucg.drawLine(Xcent, base, scanline*cos(radians(f))+Xcent,base - scanline*sin(radians(f)));
      
      // 2. Pontos de Deteção
      if (alerta) {
          ucg.setColor(255, 0, 255); // ROXO = ALERTA DE MOVIMENTO
      } else if (distance < 100) {
          ucg.setColor(255, 0, 0);   // VERMELHO = PERTO
      } else {
          ucg.setColor(255, 255, 0); // AMARELO = LONGE
      }

      if (distance < 100) {
          ucg.drawDisc(2.2*distance*cos(radians(x))+ Xcent,-2.2*distance*sin(radians(x))+base, 1, UCG_DRAW_ALL);
      } else {
          ucg.drawDisc(208*cos(radians(x))+Xcent,-208*sin(radians(x))+base, 1, UCG_DRAW_ALL);
      }
      
      ucg.setColor(0, 200, 0); 
}

void desenharTextoInfo(int x, int distance, bool alerta) {
      ucg.setFont(ucg_font_helvR08_hr);
      
      // Limpa área de texto (desenhando caixa preta por cima)
      ucg.setColor(0,0,0);
      ucg.drawBox(0, 220, 320, 20);

      ucg.setColor(255,255,  0);
      ucg.setPrintPos(20,230);
      ucg.print("DEG: "); 
      ucg.print(x);
      
      ucg.setPrintPos(150,230);
      ucg.print("DIST: ");
      ucg.print(distance);
      ucg.print(" cm"); 

      if(alerta) {
        ucg.setColor(255, 0, 255);
        ucg.setPrintPos(240, 230);
        ucg.print("ALERTA!");
      } else if (!initialScanDone) {
        ucg.setColor(0, 255, 255);
        ucg.setPrintPos(240, 230);
        ucg.print("CALIB...");
      }
}

void loop(void)
{
  // --- 1. MODO DE ESPERA (STANDBY) ---
  if (!systemActive) {
    if (digitalRead(ButtonPin) == LOW) {
      Serial.println(">>> INICIANDO SISTEMA... <<<");
      
      // Limpa ecrã e prepara grelha
      cls();
      ucg.setFontMode(UCG_FONT_MODE_SOLID);
      fix();
      fix_font();
      
      systemActive = true; 
    } else {
      return; // Fica aqui até carregar no botão
    }
  }

  // --- 2. SISTEMA ATIVO ---
  int distance;
  int storedValue; 
  bool alertaDetectado = false;
  
  // Garante que a grelha está desenhada
  // (Podes remover se causar "piscar", mas garante que a grelha não desaparece)
  if (initialScanDone) {
      // Pequeno refresh opcional
  }

  // ==========================================
  // SWEEP 0 -> 180 (Anti-Horário)
  // ==========================================
  for (int x = 0; x <= 180; x += 2){      
      
      myServo.write(x);              
      delay(stepDelay); 
      
      distance = calculateDistance();
      alertaDetectado = processarLogicaRadar(x, distance, true);
      storedValue = history0to180[x/2]; // Para debug

      // Desenho no TFT
      desenharRadar(x, distance, alertaDetectado, false);
      
      // Updates de UI e Serial a cada ~10 graus para não abrandar muito, 
      // ou sempre se preferires ver em tempo real.
      if (x % 2 == 0) { 
        if (x > 70 and x < 110) fix_font(); // Redesenha numeros centrais se passar por cima
        desenharTextoInfo(x, distance, alertaDetectado);
        
        // Serial Debug Rico
        Serial.print("DIR: >> | Ang: "); Serial.print(x); 
        Serial.print(" | Dist: "); Serial.print(distance); 
        Serial.print(" | Mem: "); Serial.print(storedValue);
        if(alertaDetectado) Serial.print(" [ALERTA]");
        Serial.println();
      }
  }

  delay(500); // Pausa na ponta

  // ==========================================
  // SWEEP 180 -> 0 (Horário)
  // ==========================================
  for (int x = 180; x >= 0; x -= 2){       
      
      myServo.write(x);              
      delay(stepDelay);
      
      distance = calculateDistance();
      alertaDetectado = processarLogicaRadar(x, distance, false); 
      storedValue = history180to0[x/2];

      // Desenho no TFT (sentido inverso = true)
      desenharRadar(x, distance, alertaDetectado, true);

      if (x % 2 == 0) {
        if (x > 70 and x < 110) fix_font();
        desenharTextoInfo(x, distance, alertaDetectado);

        // Serial Debug Rico
        Serial.print("DIR: << | Ang: "); Serial.print(x); 
        Serial.print(" | Dist: "); Serial.print(distance); 
        Serial.print(" | Mem: "); Serial.print(storedValue);
        if(alertaDetectado) Serial.print(" [ALERTA]");
        Serial.println();
      }
  }

  delay(500); // Pausa na outra ponta
  
  // Limpa o ecrã de "lixo" acumulado (scanlines) a cada ciclo completo
  cls(); 
  fix();
  fix_font();

  if (!initialScanDone) {
    initialScanDone = true;
    Serial.println("--- CALIBRAÇÃO CONCLUÍDA ---");
  }
}