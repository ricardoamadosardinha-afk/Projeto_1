#include <SPI.h>
#include <LovyanGFX.hpp> 
#include <ESP32Servo.h>

// --- CONFIGURAÇÃO DO ECRÃ (LOVYANGFX) ---
class LGFX : public lgfx::LGFX_Device {
  lgfx::Panel_ILI9488 _panel_instance; 
  lgfx::Bus_SPI       _bus_instance;   

public:
  LGFX(void) {
    {
      auto cfg = _bus_instance.config();
      
      cfg.spi_host = SPI2_HOST; 
      cfg.spi_mode = 0;
      cfg.freq_write = 40000000; 
      cfg.freq_read  = 16000000;
      cfg.spi_3wire  = false; 
      cfg.use_lock   = true;
      cfg.dma_channel = SPI_DMA_CH_AUTO;

      // Pinos ESP32-C6
      cfg.pin_sclk = 21;  
      cfg.pin_mosi = 19;  
      cfg.pin_miso = -1;  
      cfg.pin_dc   = 22;  
      
      _bus_instance.config(cfg);
      _panel_instance.setBus(&_bus_instance);
    }

    {
      auto cfg = _panel_instance.config();

      cfg.pin_cs           = 15;  
      cfg.pin_rst          = 23;  
      cfg.pin_busy         = -1; 

      cfg.panel_width      = 320;
      cfg.panel_height     = 480;
      cfg.offset_x         = 0;
      cfg.offset_y         = 0;
      cfg.offset_rotation  = 0;
      cfg.dummy_read_pixel = 8;
      cfg.dummy_read_bits  = 1;
      cfg.readable         = false; 
      cfg.invert           = false;
      cfg.rgb_order        = false;
      cfg.dlen_16bit       = false;
      cfg.bus_shared       = false; 

      _panel_instance.config(cfg);
    }
    
    setPanel(&_panel_instance);
  }
};

LGFX tft;                 
Servo myServo; 

// --- PINOS ---
#define trigPin   4   
#define echoPin   5   
#define ServoPin  14 
#define ButtonPin 2 
const int ldrPin = 1; // Pino do LDR

// --- DEFINIÇÕES DO RADAR ---
#define MAX_DISTANCE_CM 150 
#define SCAN_RADIUS 220     
#define CENTER_X 240        
#define CENTER_Y 300        
int radarSpeed = 300; // Velocidade do Servo

// --- DEFINIÇÕES DE LUZ ---
const int lightThreshold = 800; 

// --- MEMÓRIA ---
int background0to180[91];   
int background180to0[91];   

bool calibrated = false;    
bool systemActive = false;  

void setup() {
  // 1. Hardware Init
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  pinMode(ButtonPin, INPUT_PULLUP);
  
  // Configuração LDR
  pinMode(ldrPin, INPUT);
  analogReadResolution(12); // Garante leitura 0-4095
  
  for(int i=0; i<91; i++) {
    background0to180[i] = 0;
    background180to0[i] = 0;
  }

  myServo.setPeriodHertz(50);
  myServo.attach(ServoPin, 500, 2400);
  myServo.write(90);

  Serial.begin(115200);

  // 2. TFT Init
  tft.init();
  tft.setRotation(1); 
  tft.fillScreen(TFT_BLACK);

  // Ecrã de Boot
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.drawCenterString("SISTEMA HIBRIDO", CENTER_X, 80);
  tft.setTextColor(TFT_YELLOW, TFT_BLACK);
  tft.drawCenterString("PRESSIONE BOTAO", CENTER_X, 120);
  tft.drawCenterString("SERIAL DEBUG ATIVO", CENTER_X, 150);
  
  Serial.println("--- SISTEMA INICIADO ---");
  Serial.println("Aguardando botao para calibrar...");
}

int calculateDistance() { 
  digitalWrite(trigPin, LOW); 
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH); 
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH, 25000); 
  if(duration == 0) return MAX_DISTANCE_CM + 10; 
  return duration * 0.034 / 2;
}

// --- FUNÇÃO DE LUZ (Agora retorna int) ---
int verificarLuz() {
  int sensorValue = analogRead(ldrPin);
  
  // Desenho na GUI
  tft.fillRect(0, 40, 140, 40, TFT_BLACK); 
  
  if (sensorValue < lightThreshold) {
    tft.setTextColor(TFT_ORANGE, TFT_BLACK);
    tft.setTextSize(2);
    tft.setCursor(10, 45);
    tft.print("ALERTA LUZ!");
    
    tft.setTextSize(1);
    tft.setCursor(10, 65);
    tft.print("Val: "); tft.print(sensorValue);
  } else {
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.setTextSize(1);
    tft.setCursor(10, 45);
    tft.print("Luz Normal");
    tft.setCursor(10, 60);
    tft.print("Val: "); tft.print(sensorValue);
  }
  
  return sensorValue; // Retorna para usarmos no Serial
}

void drawGrid() {
  tft.drawCircle(CENTER_X, CENTER_Y, SCAN_RADIUS, TFT_DARKGREEN);       
  tft.drawCircle(CENTER_X, CENTER_Y, SCAN_RADIUS*0.66, TFT_DARKGREEN);  
  tft.drawCircle(CENTER_X, CENTER_Y, SCAN_RADIUS*0.33, TFT_DARKGREEN);  

  for (int i=30; i<=150; i+=30) {
    float rad = radians(i);
    int x = CENTER_X + SCAN_RADIUS * cos(rad);
    int y = CENTER_Y - SCAN_RADIUS * sin(rad);
    tft.drawLine(CENTER_X, CENTER_Y, x, y, TFT_DARKGREEN);
  }
}

void renderRadarLine(int angle, int distance, bool isIntruder) {
  float rad = radians(angle);
  float cosA = cos(rad);
  float sinA = sin(rad);

  int lineX = CENTER_X + SCAN_RADIUS * cosA;
  int lineY = CENTER_Y - SCAN_RADIUS * sinA;
  tft.drawLine(CENTER_X, CENTER_Y, lineX, lineY, TFT_GREEN);

  if (isIntruder && distance < MAX_DISTANCE_CM) {
    int pixelDist = map(distance, 0, MAX_DISTANCE_CM, 0, SCAN_RADIUS);
    int objX = CENTER_X + pixelDist * cosA;
    int objY = CENTER_Y - pixelDist * sinA;
    
    tft.fillCircle(objX, objY, 5, TFT_RED);
    
    tft.fillRect(0, 0, 140, 35, TFT_BLACK);
    tft.setTextColor(TFT_RED, TFT_BLACK); 
    tft.setTextSize(2);
    tft.setCursor(10, 10);
    tft.print("INTRUSO!");
  } else {
    tft.fillRect(0, 0, 140, 35, TFT_BLACK);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setTextSize(1);
    tft.setCursor(10, 10);
    tft.print("Radar Scan...");
  }

  // Debug Ecrã
  tft.fillRect(380, 0, 100, 40, TFT_BLACK);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.setCursor(390, 5); tft.print("Ang: "); tft.print(angle);
  tft.setCursor(390, 20); tft.print("Dst: "); tft.print(distance);
}

void clearRadarLine(int angle) {
  float rad = radians(angle);
  int x = CENTER_X + SCAN_RADIUS * cos(rad);
  int y = CENTER_Y - SCAN_RADIUS * sin(rad);
  tft.drawLine(CENTER_X, CENTER_Y, x, y, TFT_BLACK);
  
  if (angle % 30 == 0) tft.drawLine(CENTER_X, CENTER_Y, x, y, TFT_DARKGREEN);
}

// --- FUNÇÃO AUXILIAR PARA IMPRIMIR SERIAL ---
void printDebug(int angle, int dist, int light, bool intruder) {
  Serial.print("ANG: "); 
  if(angle < 10) Serial.print("00");
  else if(angle < 100) Serial.print("0");
  Serial.print(angle);
  
  Serial.print("\t| DIST: "); 
  Serial.print(dist);
  Serial.print("cm");
  
  Serial.print("\t| LUZ: "); 
  Serial.print(light);
  
  // Marcadores visuais de alerta
  if (intruder) Serial.print(" \t[ALERTA MOVIMENTO !!!]");
  if (light < lightThreshold) Serial.print(" \t[ALERTA LUZ !!!]");
  
  Serial.println(); // Nova linha
}

void loop() {
  // --- MODO CALIBRAÇÃO ---
  if (!systemActive) {
    if (digitalRead(ButtonPin) == LOW) {
      Serial.println(">>> INICIANDO CALIBRACAO <<<");
      tft.fillScreen(TFT_BLACK);
      
      tft.setTextColor(TFT_CYAN, TFT_BLACK);
      tft.drawCenterString("CALIBRAR IDA...", CENTER_X, 140);
      for(int i=0; i<=180; i+=2) {
        myServo.write(i);
        delay(radarSpeed);
        background0to180[i/2] = calculateDistance();
      }

      tft.fillScreen(TFT_BLACK);
      
      tft.drawCenterString("CALIBRAR VOLTA...", CENTER_X, 140);
      for(int i=180; i>=0; i-=2) {
        myServo.write(i);
        delay(radarSpeed);
        background180to0[i/2] = calculateDistance();
      }
      
      calibrated = true;
      systemActive = true;
      Serial.println(">>> CALIBRACAO CONCLUIDA <<<");
      tft.fillScreen(TFT_BLACK);
      drawGrid();
    } else {
      // Mesmo em espera, mostra a luz no serial para testar o LDR
      int valLuz = verificarLuz();
      Serial.print("STANDBY - LUZ: "); Serial.println(valLuz);
      delay(200);
      return;
    }
  }

  // --- MODO ATIVO (IDA) ---
  for (int i=0; i<=180; i+=2) {
    myServo.write(i);
    delay(radarSpeed); 
    if(i > 0) clearRadarLine(i-2);

    int distAtual = calculateDistance();
    bool intruso = false;
    int index = i / 2;
    int distFundo = background0to180[index]; 

    if (abs(distAtual - distFundo) > 10 && distAtual < MAX_DISTANCE_CM && distAtual > 0) {
      intruso = true;
    } else {
      if (abs(distAtual - distFundo) < 5) background0to180[index] = distAtual; 
    }

    renderRadarLine(i, distAtual, intruso);
    int valLuz = verificarLuz();
    
    // OUTPUT SERIAL
    printDebug(i, distAtual, valLuz, intruso);
  }
  clearRadarLine(180);

  // --- MODO ATIVO (VOLTA) ---
  for (int i=180; i>=0; i-=2) {
    myServo.write(i);
    delay(radarSpeed);
    if(i < 180) clearRadarLine(i+2);

    int distAtual = calculateDistance();
    bool intruso = false;
    int index = i / 2;
    int distFundo = background180to0[index];

    if (abs(distAtual - distFundo) > 10 && distAtual < MAX_DISTANCE_CM && distAtual > 0) {
      intruso = true;
    } else {
      if (abs(distAtual - distFundo) < 5) background180to0[index] = distAtual;
    }

    renderRadarLine(i, distAtual, intruso);
    int valLuz = verificarLuz();

    // OUTPUT SERIAL
    printDebug(i, distAtual, valLuz, intruso);
  }
  clearRadarLine(0);
}