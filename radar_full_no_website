// --- BIBLIOTECAS ---
#include <ESP32Servo.h> 
#include <SPI.h>
#include "Ucglib.h"            

// --- PINOS ESP32-C6 ---
#define  trigPin   4   
#define  echoPin   5   
#define  ServoPin  14 
#define  ButtonPin 2  // Botão entre Pino 2 e GND

// --- DEFINIÇÕES GERAIS (AJUSTADAS PARA 480x320) ---
int Ymax = 320;               // Aumentado de 240
int Xmax = 480;               // Aumentado de 320
int Xcent = Xmax / 2;         // 240
int base = 290;               // Baixou para dar mais espaço vertical
int scanline = 260;           // Raio da linha de varrimento aumentado
int stepDelay = 40;           // Velocidade do varrimento

// --- MEMÓRIA DO RADAR (91 posições para ângulos 0 a 180, passo 2) ---
int history0to180[91]; 
int history180to0[91]; 

// --- VARIÁVEIS DE ESTADO ---
bool initialScanDone = false; 
bool systemActive = false; // Controla se o sistema já arrancou

Servo myServo; 

// CONFIGURAÇÃO DO DISPLAY
// IMPORTANTE: Para ecrãs 3.5" de 480x320, o driver geralmente é ILI9486 ou HX8357.
// O ILI9341 geralmente só vai até 320x240.
// Se a imagem ficar branca ou invertida, tenta "Ucglib_HX8357..."
Ucglib_ILI9486_18x320x480_HWSPI ucg(/*cd=*/ 22, /*cs=*/ 15, /*reset=*/ 23);

void setup(void)
{
      // 1. Inicializar arrays a 0
      for(int i=0; i<91; i++) {
        history0to180[i] = 0;
        history180to0[i] = 0;
      }

      // 2. Configuração de Hardware
      myServo.setPeriodHertz(50); 
      pinMode(trigPin, OUTPUT);       
      pinMode(echoPin, INPUT);
      pinMode(ButtonPin, INPUT_PULLUP); // Botão com resistência interna
      
      Serial.begin(115200);
      Serial.println("--- RADAR A INICIALIZAR ---");

      myServo.attach(ServoPin, 500, 2400); 
      myServo.write(90); // Posição neutra ao ligar

      // 3. Inicializar TFT
      ucg.begin(UCG_FONT_MODE_SOLID); 
      
      // Rotação ajustada. Se ficar de cabeça para baixo, tenta 0, 1, 2 ou 3.
      ucg.setRotate90(); 
      
      // Ecrã de Boas Vindas / Standby (Ajustado para 480x320)
      ucg.setFontMode(UCG_FONT_MODE_TRANSPARENT);
      ucg.clearScreen();
      ucg.setColor(0, 0, 100, 0); // Fundo verde escuro
      ucg.drawGradientBox(0, 0, 480, 320);
      
      ucg.setColor(0, 255, 255, 255); // Branco
      ucg.setFont(ucg_font_logisoso32_tf);
      ucg.setPrintPos(120, 120); // Centralizado X
      ucg.print("SISTEMA");
      ucg.setPrintPos(130, 160);
      ucg.print("PRONTO");
      
      ucg.setFont(ucg_font_courB14_tf);
      ucg.setColor(0, 255, 255, 0); // Amarelo
      ucg.setPrintPos(130, 240);
      ucg.print("PRESSIONE BOTAO...");
      
      Serial.println("AGUARDANDO BOTAO...");
}

// --- FUNÇÕES AUXILIARES DE DESENHO (AJUSTADAS) ---
void cls() {
  ucg.setColor(0, 0, 0, 0);
  for(int s=0;s<320;s++) { // Altura 320
    ucg.drawHLine(0,s,480); // Largura 480
  }
}

void fix_font() {
      ucg.setColor(0, 180, 0);
      ucg.setFont(ucg_font_helvR08_hr);
      // Posições ajustadas para os novos raios (280, 185, 90) a partir da base 290
      // X = 244 (ligeiramente à direita do centro 240)
      ucg.setPrintPos(244, 20);  // ~1.00m (Topo)
      ucg.print("1.00");
      ucg.setPrintPos(244, 110); // ~0.60m
      ucg.print("0.60");
      ucg.setPrintPos(244, 205); // ~0.30m
      ucg.print("0.30");
}

void fix() {
      ucg.setColor(0, 180, 0);
      
      // Novos Raios para preencher 480x320
      int rLarge = 280;
      int rMed = 185;
      int rSmall = 90;

      ucg.drawDisc(Xcent, base+1, 4, UCG_DRAW_ALL); 
      
      // Círculos Concêntricos
      ucg.drawCircle(Xcent, base+1, rLarge, UCG_DRAW_UPPER_LEFT);
      ucg.drawCircle(Xcent, base+1, rLarge, UCG_DRAW_UPPER_RIGHT);
      ucg.drawCircle(Xcent, base+1, rMed, UCG_DRAW_UPPER_LEFT);
      ucg.drawCircle(Xcent, base+1, rMed, UCG_DRAW_UPPER_RIGHT);
      ucg.drawCircle(Xcent, base+1, rSmall, UCG_DRAW_UPPER_LEFT);
      ucg.drawCircle(Xcent, base+1, rSmall, UCG_DRAW_UPPER_RIGHT);
      ucg.drawLine(0, base+1, Xmax, base+1);
      
      ucg.setColor(0, 180, 0);
       for(int i= 40;i < 300; i+=2) {
        // Ticks ajustados para o raio ~260-280
        if (i % 10 == 0) 
          ucg.drawLine(260*cos(radians(i))+Xcent,base - 260*sin(radians(i)) , 280*cos(radians(i))+Xcent,base - 280*sin(radians(i)));
        else
          ucg.drawLine(270*cos(radians(i))+Xcent,base - 270*sin(radians(i)) , 280*cos(radians(i))+Xcent,base - 280*sin(radians(i)));
       }
}

// --- LÓGICA DO RADAR (MANTIDA) ---
int calculateDistance() { 
      long duration;
      digitalWrite(trigPin, LOW); 
      delayMicroseconds(2);
      digitalWrite(trigPin, HIGH); 
      delayMicroseconds(10);
      digitalWrite(trigPin, LOW);
      duration = pulseIn(echoPin, HIGH);
      return duration*0.034/2;
}

bool processarLogicaRadar(int angulo, int distanciaAtual, bool sentido0to180) {
    int* memoriaAtual = sentido0to180 ? history0to180 : history180to0;
    int index = angulo / 2;
    int distanciaAntiga = memoriaAtual[index];
    bool alerta = false;

    if (!initialScanDone) {
        memoriaAtual[index] = distanciaAtual;
        return false; 
    }

    if (abs(distanciaAtual - distanciaAntiga) > 20 && distanciaAntiga > 0) {
        alerta = true;
    }
    return alerta;
}

// --- DESENHO DINÂMICO (AJUSTADO ESCALA) ---
void desenharRadar(int x, int distance, bool alerta, bool sentidoInverso) {
      // 1. Linhas de Varrimento
      int f = sentidoInverso ? (x - 4) : (x + 4); 
      
      ucg.setColor(0, 255, 0); 
      ucg.drawLine(Xcent, base, scanline*cos(radians(f))+Xcent,base - scanline*sin(radians(f)));
      
      f = sentidoInverso ? (f + 2) : (f - 2);
      ucg.setColor(0, 128, 0); 
      ucg.drawLine(Xcent, base, scanline*cos(radians(f))+Xcent,base - scanline*sin(radians(f)));
      
      f = sentidoInverso ? (f + 2) : (f - 2);
      ucg.setColor(0, 0, 0);   
      ucg.drawLine(Xcent, base, scanline*cos(radians(f))+Xcent,base - scanline*sin(radians(f)));
      
      // 2. Pontos de Deteção
      if (alerta) {
          ucg.setColor(255, 0, 255); // ROXO = ALERTA
      } else if (distance < 100) {
          ucg.setColor(255, 0, 0);   // VERMELHO = PERTO
      } else {
          ucg.setColor(255, 255, 0); // AMARELO = LONGE
      }

      // --- ESCALA 480x320 ---
      // Alcance visual maximo: ~280 pixéis
      // Se alcance real for 100cm -> Fator = 2.8
      float scaleFactor = 2.8; 

      if (distance < 100) {
          ucg.drawDisc(scaleFactor*distance*cos(radians(x))+ Xcent,-scaleFactor*distance*sin(radians(x))+base, 2, UCG_DRAW_ALL);
      } else {
          // Desenha no limite visual (280px)
          ucg.drawDisc(280*cos(radians(x))+Xcent,-280*sin(radians(x))+base, 2, UCG_DRAW_ALL);
      }
      
      ucg.setColor(0, 200, 0); 
}

void desenharTextoInfo(int x, int distance, bool alerta) {
      ucg.setFont(ucg_font_helvR08_hr);
      
      // Caixa de texto movida para o fundo (Y=300) e mais larga
      ucg.setColor(0,0,0);
      ucg.drawBox(0, 300, 480, 20);

      ucg.setColor(255,255,  0);
      ucg.setPrintPos(40,312); // Posições X espaçadas para ecrã largo
      ucg.print("DEG: "); 
      ucg.print(x);
      
      ucg.setPrintPos(200,312);
      ucg.print("DIST: ");
      ucg.print(distance);
      ucg.print(" cm"); 

      if(alerta) {
        ucg.setColor(255, 0, 255);
        ucg.setPrintPos(360, 312);
        ucg.print("ALERTA!");
      } else if (!initialScanDone) {
        ucg.setColor(0, 255, 255);
        ucg.setPrintPos(360, 312);
        ucg.print("A CALIBRAR...");
      }
}

void loop(void)
{
  // --- 1. MODO DE ESPERA ---
  if (!systemActive) {
    if (digitalRead(ButtonPin) == LOW) {
      Serial.println(">>> INICIANDO SISTEMA... <<<");
      
      cls();
      ucg.setFontMode(UCG_FONT_MODE_SOLID);
      fix();
      fix_font();
      
      systemActive = true; 
    } else {
      return; 
    }
  }

  // --- 2. SISTEMA ATIVO ---
  int distance;
  int storedValue; 
  bool alertaDetectado = false;
  
  if (initialScanDone) {
      // Refresh opcional
  }

  // SWEEP 0 -> 180
  for (int x = 0; x <= 180; x += 2){      
      
      myServo.write(x);              
      delay(stepDelay); 
      
      distance = calculateDistance();
      alertaDetectado = processarLogicaRadar(x, distance, true);
      storedValue = history0to180[x/2]; 

      desenharRadar(x, distance, alertaDetectado, false);
      
      if (x % 2 == 0) { 
        if (x > 70 and x < 110) fix_font(); 
        desenharTextoInfo(x, distance, alertaDetectado);
        
        Serial.print("DIR: >> | Ang: "); Serial.print(x); 
        Serial.print(" | Dist: "); Serial.print(distance); 
        Serial.print(" | Mem: "); Serial.print(storedValue);
        if(alertaDetectado) Serial.print(" [ALERTA]");
        Serial.println();
      }
  }

  delay(500); 

  // SWEEP 180 -> 0
  for (int x = 180; x >= 0; x -= 2){       
      
      myServo.write(x);              
      delay(stepDelay);
      
      distance = calculateDistance();
      alertaDetectado = processarLogicaRadar(x, distance, false); 
      storedValue = history180to0[x/2];

      desenharRadar(x, distance, alertaDetectado, true);

      if (x % 2 == 0) {
        if (x > 70 and x < 110) fix_font();
        desenharTextoInfo(x, distance, alertaDetectado);

        Serial.print("DIR: << | Ang: "); Serial.print(x); 
        Serial.print(" | Dist: "); Serial.print(distance); 
        Serial.print(" | Mem: "); Serial.print(storedValue);
        if(alertaDetectado) Serial.print(" [ALERTA]");
        Serial.println();
      }
  }

  delay(500); 
  
  cls(); 
  fix();
  fix_font();

  if (!initialScanDone) {
    initialScanDone = true;
    Serial.println("--- CALIBRAÇÃO CONCLUÍDA ---");
  }
}